<!DOCTYPE HTML>
<html>

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />		
	<title>appledoc @ GitHub</title>
	<link rel="stylesheet" type="text/css" media="screen" href="styles.css"  />
</head>

<body>
	<article id="contents" role="main">
		<div id="header">
			<div id="download">
			  <a href="http://github.com/tomaz/appledoc/zipball/master">
			    <img width="90" src="http://github.com/images/modules/download/zip.png"></a>
			  <a href="http://github.com/tomaz/appledoc/tarball/master">
			    <img width="90" src="http://github.com/images/modules/download/tar.png"></a>
			</div>
			<a href="http://github.com/tomaz/appledoc"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub" /></a>
			<h1>appledoc</h1>
			<p>Objective-C documentation set generator.</p>
		</div>
		<div id="container">
			<h2>Advanced command line examples</h2>
			<div class="cmdlineexamplesection">
			<p>This section contains additional examples and descriptions of command line switches which usage may not be immediately obvious.</p>
			
				<a name="publishDocSet"></a>
				<h3>Prepare documentation set for publishing</h3>
				<p>appledoc can prepare documentation set for publishing too, just add <code>--publish-docset</code>, <code>--docset-feed-url</code> and <code>--docset-package-url</code> switches to command line like this:
<pre>appledoc
--project-name appledoc
--project-company "Gentle Bytes"
--company-id com.gentlebytes
--output ~/Projects/Help/appledoc
--docset-feed-url http://gentlebytes.com/downloads/%DOCSETATOMFILENAME
--docset-package-url http://gentlebytes.com/downloads/%DOCSETPACKAGEFILENAME
--publish-docset 
.</pre>
				This command line will create and install documentation set and finally run docsetutil over installed docset to create compressed documentation set file and atom feed you can upload to your server. Both files are saved to <code>publish</code> subdirectory within <code>--output</code> path. You can then pass them to <code>rsync</code> or similar tool for actually uploading to your server (although command line switch may suggest so, appledoc doesn't do uploading itself, it only generates necessary files!). When uploading, make sure the files are available at the URLs given to <code>--docset-feed-url</code> and <code>--docset-package-url</code>! You can use <a href="#miscellaneousCmdLine"><code>--print-settings</code></a> command line switch to have appledoc print the actual URLs after replacing <a href="#placeholders">template placeholders</a>.</p>
				<div class="warning">
				<p><strong>Important:</strong> When you increment versions, the atom file needs to be updated properly - a new entry needs to be inserted for each new version. To allow that, appledoc checks if the atom file already exists at output path. If so, the existing file is updated with new information by docsetutil. First the file is parsed and if an entry is found corresponding to <code>--project-version</code>, the entry is updated. If no entry matching the version is found, a new entry is added to the file. Therefore it is important to keep the generated atom file at output path (you can safely remove package (.xar file) after uploading though)! In fact, this is the mechanism used by appledoc to have the atom file updated with new versions, so keep that in mind!</p>
				</div>
				<div class="warning">
				<p><strong>Note:</strong> Notice the usage of <code>%DOCSETATOMFILENAME</code> and <code>%DOCSETPACKAGEFILENAME</code> placeholders for command line switches - it is <a href="#placeholders">recommended to use these</a> to keep the actual filenames in sync with information written to atom file!</p>
				</div>
				<div class="warning">
				<p><strong>Note:</strong> You can also include <code>--docset-fallback-url</code> so that Xcode can get to your documentation installed on remote server. The location given should point to the contents of your DocSet <code>Documents</code> folder (at present appledoc doesn't prepare a copy of this folder, you can find it either at <code>--docset-install-path</code> (if you use default value, add <a href="#miscellaneousCmdLine"><code>--print-settings</code></a> command line switch to have it printed for you) or alternatively use <code>--keep-intermediate-files</code> and find the files at your <code>--output</code> location).</p>
				</div>


				<a name="undocumentedCmdLine"></a>
				<h3>Undocumented objects and members handling</h3>
				<p>By default appledoc ignores all undocumented classes, categories, protocols as well as methods and properties. However you can instruct it to include undocumented objects and members in generated HTML:
<pre>appledoc
--project-name appledoc
--project-company "Gentle Bytes"
--company-id com.gentlebytes
--output ~/Projects/Help/appledoc
--keep-undocumented-objects
--keep-undocumented-members
--search-undocumented-doc
.</pre>
				This command line would include every parsed object (class, category and protocol) and it's member (method or property). Additionally it would search for documentation of undocumented members in super classes and adopted protocols. To better understand how these switched interact with each other this is the workflow used:
				<ul>
					<li>If <code>--search-undocumented-doc</code> is enabled, all undocumented methods and properties documentation is searched for in known super class hierarchy. If documentation is found in any of the super classes, it is copied to inherited member as well. If documentation is not found in superclasses, it is searched for in adopted protocols and copied from there if possible. If disabled, members are left undocumented and are handled that way as described below. This option is enabled by default (in fact above example doesn't need to enable it explicitly); to disable, use <code>--no-search-undocumented-doc.</code></li>
					<li>If <code>--keep-undocumented-members</code> is enabled, all undocumented methods and properties are left and used for output. If disabled, any undocumented method or property is removed from class (of course any documentation copied over from super classes or adopted protocols in previous step is considered valid too). This option is disabled by default.</li>
					<li>If <code>--keep-undocumented-objects</code> is enabled, all undocumented classes, categories and protocols are left. If disabled, all undocumented objects that have no documented method or property are also removed. However if undocumented object contains documented members, the object is left and used for output regardless of this option (overview section would be ommited in generated HTML)! This option is disabled by default.</li>
				</ul></p>
				
				
				<a name="mergeCmdLine"></a>
				<h3>Merging category documentation</h3>
				<p>Apple seems to merge categories documentation to it's class to keep it together and appledoc is configured to do the same:
<pre>appledoc
--project-name appledoc
--project-company "Gentle Bytes"
--company-id com.gentlebytes
--output ~/help
--merge-categories
.</pre>
				This command line will merge categories and extension documentation to their classes as long as the class is also found in the given source files. In fact, this behavior is enabled by default, so you can skip <code>--merge-categories</code> switch in the above example and get the same result. You can refine how categories are merged with two additional switches:
				<ul>
					<li><code>--keep-merged-sections</code>: If enabled, all <a href="comments.html#misc">@name sections</a> from categories are preserved, otherwise all methods from category are merged into a single section using category name as section title. This is disabled by default as this seems to be how Apple does it. Enabling this option may result in fragmented class documentation, so experiment a bit to see what works best for you.</li>
					<li><code>--prefix-merged-sections</code>: If enabled, all merged category section titles are prefixed with category name, otherwise original title is left. This is disabled by default, but you can enable it if it suits you better - again, experiment to see what works for you. This switch is ignored unless <code>--keep-merged-section</code> is enabled! <strong>Important:</strong> extension sections are never prefixed regardless of this setting!</li>
				</ul>
				Both switches are ignored if categories merging is disabled (i.e. <code>--no-merge-categories</code>!</p>



				<a name="crossrefsdetection"></a>
				<h3>Controlling cross references detection</h3>
				<p>By default any valid cross reference word or URL, optionally embedded within <code>&lt;&gt;</code> markers is converted to cross reference link in resulting documentation. Although this greatly simplifies cross references handling, it may lead to unexpected links. For example if one of your methods or properties has selector <code>paragraph</code>, every word <em>paragraph</em> is converted to cross reference to that method. To give you control over which word should be converted to cross reference and which shouldn't, appledoc allows you to turn on explicit cross references like this:
<pre>appledoc
--project-name appledoc
--project-company "Gentle Bytes"
--company-id com.gentlebytes
--output ~/help
--explicit-crossref
.</pre>
				This command line will check cross references only in words embedded with <code>&lt;&gt;</code> markers. This gives you control over which word should be converted to cross references and which not, but requires you to use additional syntax; above example would need to be written as <code>&lt;paragraph&gt;</code>. Note: without explicit cross references option, you can still embed words with <code>&lt;&gt;</code> markers - this is optional by default, but with explicit option, markers are required!</p>
				
				<p>Further more, if you don't like default markers, you can use arbitrary ones for embedding cross references in your code. This is great for porting your code from other documenting systems. Here's an example:
<pre>appledoc
--project-name appledoc
--project-company "Gentle Bytes"
--company-id com.gentlebytes
--output ~/help
--crossref-format "#%@#"
.</pre>
				This example would only check for cross references embedded within <code>##</code> markers, for example <code>#paragraph#</code>. Even more, <code>--crossref-format</code> takes regex expression, so you can become very creative. For example, to change markers to <code>#</code> and make them optional, you'd use <code>--crossref-format "#?%@#?"</code> instead. Make sure you don't forget to include <code>%@</code> placeholder - this is replaced with actual cross reference matching regexes for various types of links!</p>
				
				<div class="warning">
				<p><strong>Important:</strong> Take care when specifying custom markers - make sure you don't use one of the <a href="comments.html#formatting">formatting markers</a> (<code>*</code>, <code>_</code> and similar); although appledoc will not warn you about it, results are unpredictable and either cross reference or format will not be recognized. Also make sure to not use capturing parenthesis (this is especially important for starting marker)! Cross references matching relies on exact capture group numbers for finding specific parts of reference (like object and method for remote members), so introducing new capturing parenthesis would break that! But you can use non-capturing parenthesis <code>(?:...)</code> if needed.</p>
				</div>

				<div class="warning">
				<p><strong>Note:</strong> <code>--crossref-format</code> and <code>--explicit-crossref</code> cmd line switches are mutually exclusive! Internally, appledoc uses <code>&lt;?%@&gt;?</code> for cross references matching, which makes markers optional. Using <code>--explicit-crossref</code> is equal to using <code>--crossref-format "&lt;%@&gt;"</code> and is in fact just a convenience shortcut for it! If you use both options in command line, the last one found will be used!</p>
				</div>
								
				<div class="warning">
				<p><strong>Note:</strong> Note that you must use quotes with <code>--crossref-format</code> even if no whitespace is included with the option!</p>
				</div>
				
				
				
				<a name="inspectCmdLine"></a>
				<h3>Inspect generated HTML or documentation set files</h3>
				<p>appledoc output generation works in several steps (i.e. generate HTML, generate docset, install docset). Each step output files are used as source for next step. For performance reasons, files are moved instead of copied between these steps by default. Although this makes appledoc more efficient, it may seem strange to see output folder empty when appledoc finishes. If so, just think of --output switch as the path to temporary files used during generation. In most cases these intermediate files are not needed and are later removed manually anyway. However there are occasions where you'd want to inspect output; debugging or archiving for example. You can tell appledoc to copy instead of move like this:
<pre>appledoc
--project-name appledoc
--project-company "Gentle Bytes"
--company-id com.gentlebytes
--output ~/help
--keep-intermediate-files
.</pre>
				Using this option all intermediate files (i.e. HTML and docset files, including docset description XML files) are kept in output path.</p>
				<p>Alternatively you can tell appledoc to only create HTML files:
<pre>appledoc
--project-name appledoc
--project-company "Gentle Bytes"
--company-id com.gentlebytes
--output ~/help
--no-create-docset
.</pre>
				By adding <code>--no-create-docset</code> you instruct appledoc to create HTML and then quit. Using this command line, you'll find HTML files in ~/help/html.
				</p>
				<p>Similarly you can tell appledoc to create docset but not install it:
<pre>appledoc
--project-name appledoc
--project-company "Gentle Bytes"
--company-id com.gentlebytes
--output ~/help
--no-install-docset
.</pre>
				Using this command line you'll find docset files in ~/help/docset. The docset is already indexed with all description xml files used for indexing left so you can inspect them. Note that in this case, html directory is moved inside ~/help/docset which effectively removes it from output path.</p>
				<p>You can also disable HTML files generation by using <code>--no-create-html</code> switch. This effectively disables any output generation and only invokes source code parsing and comments processing. As generation phase takes most time (typically more than 90%!), this option is useful for quick validation of your comments for unknown cross references and similar. It may come handy to include it as a regular build phase for larger targets to validate your comments and then manually invoke generation before releasing.</p>
							
			</div>

			<p><a href="settings.html#examples">Back to settings</a></p>
		</div>
		<div id="aside">
			<h2>Contents</h2>
			<p>
			<ul>
				<li><a href="index.html">About</a></li>
				<li><a href="comments.html">Comments</a></li>
				<li><a href="settings.html">Settings</a></li>
			</ul>
			</p>
		</div>
		<div id="footer">
			&copy; 2009-2010 <a href="http://gentlebytes.com">Gentle Bytes</a>. All rights reserved.
		</div>
	</article>
	<script type="text/javascript">
	var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
	document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
	</script>
	<script type="text/javascript">
	try {
	var pageTracker = _gat._getTracker("UA-11836532-1");
	pageTracker._trackPageview();
	} catch(err) {}</script>
	<script type="text/javascript">
    var GoSquared={};
    GoSquared.acct = "GSN-255527-N";
    (function(w){
        function gs(){
            w._gstc_lt=+(new Date); var d=document;
            var g = d.createElement("script"); g.type = "text/javascript"; g.async = true; g.src = "//d1l6p2sc9645hc.cloudfront.net/tracker.js";
            var s = d.getElementsByTagName("script")[0]; s.parentNode.insertBefore(g, s);
        }
        w.addEventListener?w.addEventListener("load",gs,false):w.attachEvent("onload",gs);
    })(window);
	</script>
</body>

</html>